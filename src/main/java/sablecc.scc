Helpers
    all_chars = [ 0 .. 65535 ];
    first_digit = ['1' .. '9'];
    digit = ['0' + first_digit];
    underscore = '_';
    not_a_digit = [underscore + [['a' .. 'z'] + ['A' .. 'Z']]];
    number = digit+;

    cr = 13;
    lf = 10;
    next_line = 0x85;
    line_separator = 0x2028;
    paragraph_separator = 0x2029;
    newline = cr | lf | cr lf | next_line | line_separator | paragraph_separator;
    newline_chars = [[[[ cr + lf ] + next_line ] + line_separator ] + paragraph_separator ];
    input_char = [ all_chars - newline_chars ];
    input_chars = input_char+;
    not_slash_input_char = [ input_char - '/'];

    tab = 9;
    all_but_star = [all_chars - '*'];
    all_but_star_and_slash = [all_but_star - '/'];

    string_literal_char = [all_chars - '"'];
    string_literal = '"' string_literal_char* '"';

Tokens
    // static names
    public = 'public';
    using_symbol = 'using_symbol';
    system_symbol = 'System';
    namespace_symbol = 'namespace';
    class_symbol = 'class';
    semicolon = ';';
    static_symbol = 'static';
    void_symbol = 'void';
    main_symbol = 'Main';
    write_line = 'Console.WriteLine';
    dot = '.';
    comma = ',';

    // comments
    one_line_comment = '//' (not_slash_input_char input_chars?)?;
    // TODO
    block_comment = '/*' all_but_star* '*'+ (all_but_star_and_slash all_but_star* '*'+)* '/';

    // literals
    int_symbol = 'int';
    double_symbol = 'double';
    string_symbol = 'string';
    bool_symbol = 'bool';
    true = 'true';
    false = 'false';
    double_value = number? '.' number;
    int_value = number;
    string_literal = string_literal;

    //unary operations
    log_not = '!';

    // operations
    mul = '*';
    div = '/';
    mod = '%';
    plus = '+';
    minus = '-';

    // relop
    lt = '<';
    lteq = '<=';
    gt = '>';
    gteq = '>=';
    eq = '==';
    neq = '!=';

    // bools
    log_and = '&&';
    log_or = '||';

    if = 'if';
    else ='else';
    return_symbol = 'return';
    l_brace = '{';
    r_brace = '}';
    l_par = '(';
    r_par = ')';
    l_bracket = '[';
    r_bracket = ']';
    equals = '=';


    whitespace = (cr | lf | tab | ' ')+;

    identifier = not_a_digit (digit | not_a_digit)*;
    number = number;

Ignored Tokens
    whitespace,
    one_line_comment,
    block_comment;

Productions
    // program structure, that is ALWAYS the same
    start = using_symbol system_symbol semicolon
            namespace_symbol [namespace_identifier]:identifier
            [first_code_block_opening]:l_brace
                class_symbol [class_identifier]:identifier
                [class_code_block_opening]:l_brace
                    class_content*
                [class_code_block_closing]:r_brace
            [first_code_block_closing]:r_brace;


    class_content =
    {block}             code_block              |
    {declaration}       decl_statement   |                                       // int number  = 3.459
    {method}            method_declaration;                                             // static int fib =

    //TODO
    //main method, needs to exist
    //main_method = static_symbol void_symbol main_symbol l_par string_symbol l_bracket r_bracket identifier r_par l_brace void_method_body r_brace;

    method_declaration =
            static_symbol type identifier l_par parameter_list? r_par method_body |
    {void}  static_symbol void_symbol identifier l_par parameter_list? r_par method_body;

    method_body = l_brace statement* r_brace;

    // data types
    type =
    {int}       int_symbol      |
    {double}    double_symbol   |
    {bool}      bool_symbol     |
    {string}    string_symbol;

    parameter_list = parameter parameter_list_tail?;
    parameter_list_tail = comma parameter parameter_list_tail?;

    parameter = type identifier;

    // Literals
    literal =
    {true}          true                |                                       // true
    {false}         false               |                                       // false
    {int_value}     int_value           |                                       // 5
    {double_value}  double_value        |                                       // 3.459
    {string}        string_literal;                                             // "Hello World"


    argument_list = expression argument_list_tail*;
    argument_list_tail = comma expression;

    // expressions
    // precedence: unary > mul > add > relation > equal > and > or
    simple_expression =
    {literal}   literal                 |                                       // true, false, 5, 3.459, "Hello World"
    {par}       l_par expression r_par  |                                       // (expression)
    {invoke}    invoke_expression;                                              // method-call

    invoke_expression = identifier l_par argument_list? r_par;                  // method-call, e.g.: "fib(3)"

    unary_expression =
            simple_expression           |                                       // base case
    {plus}  plus simple_expression      |                                       // +5
    {minus} minus simple_expression     |                                       // -5
    {not}   log_not simple_expression;                                              // !5

    mul_expression =
                unary_expression                     |                          // base case
    {mul}       mul_expression mul unary_expression  |                          // E1 * E2
    {div}       mul_expression div unary_expression  |                          // E1 / E2
    {mod}       mul_expression mod unary_expression;                            // E1 % E2


    add_expression =
                mul_expression                      |                           // base case
    {plus}      add_expression plus mul_expression  |                           // E1 + E2
    {minus}     add_expression minus mul_expression;                            // E1 - E2

    rel_expression =
                add_expression                      |                           // base case
    {lt}        rel_expression lt add_expression    |                           // E1 < E2
    {gt}        rel_expression gt add_expression    |                           // E1 > E2
    {lteq}      rel_expression lteq add_expression  |                           // E1 <= E2
    {gteq}      rel_expression gteq add_expression;                             // E1 >= E2

    //TODO
    // maybe check for && fucking it up like: "cond = true && f1 == f2"
    equality_expression =
                    rel_expression                          |                   // base case
    {equals}        equality_expression eq rel_expression   |                   // E1 == E2
    {not_equals}    equality_expression neq rel_expression;                     // E1 != E2

    conditional_and_expression =
            equality_expression                                     |           // base case
    {and}   conditional_and_expression log_and equality_expression;             // E1 && E2

    conditional_expression =
            conditional_and_expression                              |           // base case
    {or}    conditional_expression log_or conditional_and_expression;           // E1 || E2

    statement =
    {declaration}           decl_statement |                             // var = value
    {embedded_statement}    embedded_statement;                                 // codeblocks like if-else, loops,...

    decl_statement = local_var_declaration semicolon;

    local_var_declaration = type var_declarators;                               // int [i]

    var_declarators = var_declarator var_declarators_tail*;                     // int [i] (, [j], [k], ...)

    var_declarators_tail = comma var_declarator;                               // int [i],[j],[k]...

    var_declarator =
    {declaration}   identifier                  |                               // int name;
    {initialize}    identifier equals expression;                               // int name = [expr];

    expression =
    //TODO
    {assignment}    assignment                  |
    {cond}   conditional_expression;

    //TODO
    embedded_statement =
    {block} code_block;         /* |
    {if}    if_statement        |
    {if_else} if_else_statement |
    {while} while_statement;
*/
    code_block = l_brace statement* r_brace;

    //TODO
    assignment = dot;

